/**
 * Represents a flight. A Flight object is represented by the flight's origin,destination,
 * departure time, flight duration, no of passengers,if it is full and the price.
 * 
 * @author: Maya Katan
 * @Date: 14.05.2022
 * @ID: 318266913
 */

public class Flight
{
    // instance variables and an constant
    private int _flightDuration, _noOfPassengers, _price;
    private String _origin, _destination;
    private boolean _isFull;
    private Time1 _departure;
    private final int MAX_CAPACITY = 250;
    int MIN = 0;
    
    // constructor which gets parameters
    /**
     * Constructor for a Flight object.
     * If the number of passengers exceeds the maximum capacity the number of passengers will
     * be set to the maxmum capacity If the number of passengers is negative the number of
     * passengers will be set to zero. If the flight duration is negative the flight duration
     * will be set to zero. If the price is negative the price will be set to zero.
     * 
     * @param destination  The city the flight lands at.
     * @param origin  The city the flight leaves from.
     * @param depHour  the departure hour (should be between 0-23).
     * @param depMinute  The departure minute (should be between 0-59).
     * @param flightDuration  The duration time in minutes(should not be negative).
     * @param noOfPassengers  The number of passengers (should be between 0-maximum capacity).
     * @param price  The price (should not be negative).
     */
    public Flight(String origin, String destination, int depHour,
                  int depMinute,int flightDuration, int noOfPassengers, int price) 
    {
        if(noOfPassengers > MAX_CAPACITY) {
            _noOfPassengers = MAX_CAPACITY;
        }
        else if(noOfPassengers < MIN) {
            _noOfPassengers = MIN;
        }
        else {
            _noOfPassengers = noOfPassengers;
        }
        
        if((noOfPassengers == MAX_CAPACITY)){
            this._isFull = true;
        }
        else {
            this._isFull = false;
        }
        
        if(flightDuration < MIN) {
            _flightDuration = MIN;
        }
        else {
            _flightDuration = flightDuration;
        }
        
        if(price < MIN) {
            _price = MIN;
        }
        else {
            _price = price;
        }
        
        this._origin = origin;
        this._destination = destination;
        _departure = new Time1(depHour,depMinute);
    }

    // copy constructor
    /**
     * Copy constructor for a Flight object.
     * Construct a Flight object with the same attributes as another Flight object.
     * 
     * @param other  The Flight object from which to construct the new Flight.
     */
    public Flight(Flight other)
    { 
        _flightDuration = other._flightDuration;
        _noOfPassengers = other._noOfPassengers;
        _price = other._price;
        _origin = other._origin;
        _destination = other._destination;
        _isFull = other._isFull;
        _departure = new Time1(other._departure);
    }
    
    // get methods
    /**
     * Returns the flight duration time in minutes.
     *
     * @return  The flight duration.
     */
    public int getFlightDuration()
    { 
        return _flightDuration;
    }
    
    /**
     * Returns the number of passengers on the flight.
     *
     * @return  The number of passengers.
     */
    public int getNoOfPassengers()
    { 
        return _noOfPassengers;
    }
    
    /**
     * Returns the price of the flight .
     *
     * @return  The price.
     */
    public int getPrice()
    { 
        return _price;
    }
    
    /**
     * Returns the flight origin.
     *
     * @return  The flight origin.
     */
    public String getOrigin()
    { 
        return new String (_origin);
    }
    
    /**
     * Returns the flight destination.
     *
     * @return  The flight destination.
     */
    public String getDestination()
    { 
        return _destination;
    }
    
    /**
     * Returns whether the flight is full or not.
     *
     * @return  True if the flight is full.
     */
    public boolean getIsFull()
    { 
        return _isFull;
    }
    
    /**
     * Returns the flight departure time.
     *
     * @return  A copy of the flight departure time.
     */
    public Time1 getDeparture() 
    { 
        return _departure = new Time1(_departure);
    }
    
    // set methods
    /**
     * An example of a method - replace this comment with your own
     *
     * @param flightDuration  The flight's new duration time.
     */
    public void setFlightDuration(int flightDuration)
    { 
        if(flightDuration >= MIN){
        _flightDuration = flightDuration;
        }
    }
    
    /**
     * Changes the number of passengers. If the parameter is negative or larger than the
     * maximum capacity the number of passengers will remain unchanged.
     *
     * @param noOfPassengers  The new number of passengers.
     */
    public void setNoOfPassengers(int noOfPassengers)
    { 
        if((noOfPassengers >= MIN) && (noOfPassengers <= MAX_CAPACITY)){
        _noOfPassengers = noOfPassengers;
        }
        
        if(_noOfPassengers != MAX_CAPACITY){
            _isFull = false;     
        }
        else{
            _isFull = true;
        }
    }
    
    /**
     * Changes the flight price. If the parameter is negative the price will remain unchanged.
     *
     * @param price  The new price.
     */
    public void setPrice(int price)
    { 
        if(price >= MIN){
        _price = price;
        }   
    }   
    
    /**
     * Changes the flight's origin.
     *
     * @param origin  The flight's new origin.
     */
    public void setOrigin(String origin)
    { 
        _origin = origin;
    }
    
    /**
     * Changes the flight's destination.
     *
     * @param destination  The flight's new destination.
     */
    public void setDestination(String destination)
    { 
        _destination = destination;
    }
    
    /**
     * Changes the flight's departure time.
     *
     * @param departure  The flight's new departure time.
     */
    public void setDeparture(Time1 departure)
    { 
        _departure = new Time1(departure);
    }
    
    // toString method
    /**
     * Return a string representation of this flight
     * (for example: "Flight from London to Paris departs at 09:24.Flight is full.").
     *
     * @param return  String representation of this flight
     * (for example: "Flight from London to Paris departs at 09:24.Flight is full.").
     */
    public String toString()
    { 
        
        if(_isFull) {
            return "Flight from " +_origin+ " to " +_destination+
                   " departs at " +_departure+ ". Flight is full.";
        }
        else {
            return "Flight from " +_origin+ " to " +_destination+
                   " departs at " +_departure+ ". Flight is not full.";
        }
    }
    
    // calculation methods
    // arrival time
    /**
     * Returns the arrival time of the flight .
     *
     * @return  The arrival time of this flight.
     */
    public Time1 getArrivalTime()
    {
        return _departure.addMinutes(_flightDuration);
    }
    // pessengers addition
    /**
     * Add passengers to this flight. If the number of passengers exceeds he maximum capacity,
     * no passengers are added and alse is returned.
     * If the flight becomes full, the boolean attribute describing whether the flight if
     * full becomes true.
     *
     * @param num  The number of passengers to be added to this flight.
     * 
     * @return  True if the passengers were added to the flight.
     */
    public boolean addPassengers(int num)
    {
        if(_isFull || _noOfPassengers + num > MAX_CAPACITY) {
            return false;
        }
        else if(_noOfPassengers + num == MAX_CAPACITY) {
            _noOfPassengers = _noOfPassengers + num;
            _isFull = true;
            return true;
        }
        else {
            _noOfPassengers = _noOfPassengers + num;
            return true;
        }
    }
    // total price
    /**
     * Calculate the total price of the flight.
     *
     * @return  The total price of the flight.
     */
    public int totalPrice()
    { 
        return _noOfPassengers * _price;
    }
    
    // other methods
    /**
     * Check if the received flight is equal to this flight.
     * Flights are considered equal if the origin, destination and departure times are the same.
     *
     * @param other  The flight to be compared with this flight.
     * 
     * @return  True if the received flight is equal to this flight.
     */
    public boolean equals(Flight other)
    {
        return ((_origin.equals(other._origin)) &&
               (_destination.equals(other._destination)) &&
               (_flightDuration == other._flightDuration));
    }
    
    /**
     * Check if this flight is cheaper than another flight.
     *
     * @param other  The flight whose price is to be compared with this flight's price.
     * 
     * @return  True if this flight is cheaper than the received flight .
     */
    public boolean isCheaper(Flight other)
    {
        return _price < other._price;
    }
    
    /**
     * Check if this flight lands before another flight.
     * Note - the flights may land on different days, the method checks which flight lands first.
     *
     *@param other  The flight whose arrival time to be compared with this flight's arrival time.
     *
     * @return  True if this flight arrives before the received flight.
     */
    public boolean landsEarlier(Flight other)
    { 
        return this.getArrivalTime().before(other.getArrivalTime());
    }
    
}// end of class Flight





/**
 * Represents time - hours:minutes. Coordinates cannot be negative.
 *
 * @author: Maya Katan
 * @Date: 14.05.2022
 * @ID: 318266913
 */

public class Time1
{
    // instance variables and contants
    private int _hour, _minute;
    private final int MAX_HOUR = 24, MAX_MINUTE = 60, MIN = 0;
    int MINUTES_A_DAY = 1440;  // The number of minutes in pone day. 
    
    // constructor which gets parameters
    /**
     * Constructs a Time1 object.
     * Construct a new time instance with the specified hour and minute.
     * hour should be between 0-23, otherwise it should be set to 0. minute should be between 0-59,
     * otherwise it should be set to 0.
     * 
     * @param h  the hour of the time
     * @param m  the minute of the time
     */
    public Time1(int h, int m)
    { 
        if (h < MAX_HOUR && h >= MIN) {
            _hour = h;
        }
        else {
            _hour = MIN;
        }
        
        if (m < MAX_MINUTE && m >= MIN) {
            _minute = m;
        }    
        else {
            _minute = MIN;
        }
    }

    // copy constructor
    /**
     * Copy constructor for Time1.
     * Construct a time with the same instance variables as another time.
     *
     * @param other  The time object from which to construct the new time
     */
    public Time1(Time1 other)
    { //API complete
        _hour = other._hour;
        _minute = other._minute;
    }
    
    // get method
    /**
     * Returns the hour of the time.
     *
     * @return  The hour of the time
     */
    public int getHour()
    {
        return _hour;
    }
    
    /**
     * Returns the minute of the time.
     *
     * @return  The minute of the time
     */
    public int getMinute()
    {
        return _minute;
    }
    
    // set method
    /**
     * Changes the hour of the time. If an illegal number is received hour will be unchanged.
     *
     * @return  The new hour
     */
    public void setHour(int num)
    { 
        if (num >= MIN && num < MAX_HOUR)
            _hour = num;
    }  
    
    /**
     * Changes the minute of the time. If an illegal number is received minute will be unchanged.
     *
     * @return  The new minute
     */
    public void setMinute(int num)
    { 
        if (num >= MIN && num < MAX_MINUTE)
            _minute = num;
    }
    
    // toString method
    /**
     * Return a string representation of this time (hh:mm).
     *
     * @return  String representation of this time (hh:mm).
     */
    public String toString()
    { 
        if(this._hour > 9 && this._minute > 9) {
            return this._hour+ ":" +this._minute;
        }
        else if (this._hour > 9 && this._minute < 10) {
            return this._hour+ ":0" +this._minute;
        }
        else if (this._hour < 10 && this._minute > 9) {
            return "0" +this._hour+ ":" +this._minute;
        }
        else {
            return "0" +this._hour+ ":0" +this._minute;
        }
    }

    // time in minutes since midnight calculation method
    /**
     * Return the amount of minutes since midnight.
     *
     * @return  amount of minutes since midnight.
     */
    public int minFromMidnight()
    { 
        return ((this._hour * MAX_MINUTE) + this._minute);
    }
    
    // other methods
    /**
     * Check if the received time is equal to this time.
     *
     * @param other  The time to be compared with this time
     * 
     * @return True if the received time is equal to this time
     */
    public boolean equals(Time1 other)
    { 
        return (this.minFromMidnight() == other.minFromMidnight());
    }
    
    /**
     * Check if this time is before a received time.
     *
     * @param other  The time to check if this time is before
     * 
     * @return  True if this time is before other time
     */
    public boolean before(Time1 other)
    { 
        return (this.minFromMidnight() < other.minFromMidnight());
    }
    
    /**
     * Check if this time is after a received time.
     *
     * @param other  The time to check if this time is after
     * 
     * @return  True if this time is after other time
     */
    public boolean after(Time1 other)
    { 
        return (this.minFromMidnight() > other.minFromMidnight());
    }
    
    /**
     * Calculates the difference (in minutes) between two times.
     * Assumption: this time is after other time.
     * 
     * @param other  The time to check the difference to
     * 
     * @return  int difference in minutes
     */
    public int difference(Time1 other)
    { 
        return (this.minFromMidnight() - other.minFromMidnight());
    }
    
    // addition minutes calculation method
    /**
     * Copy current object and add requested minutes to new object.
     * 
     * @param num The minutes need to add.
     * 
     * @return  new update Time1 object.
     */
    public Time1 addMinutes(int num) 
    { 
        int m = minFromMidnight();
        m += num;
        m %= MINUTES_A_DAY;
        if(m < MIN){
            m += MINUTES_A_DAY;
        }
        return new Time1(m / MAX_MINUTE, m % MAX_MINUTE);
    }
}// end of class Time1





/**
 * Represents time - hours:minutes. Values must represent a proper time.
 *
 * @author: Maya Katan
 * @Date: 14.05.2022
 * @ID: 318266913
 */

public class Time2
{
    // variable and constants
    private int _minFromMid;
    private final int MAX_HOUR = 24, MAX_MINUTE = 60, MIN = 0;
    
    // constructor which gets parameters
    /**
     * Constructs a Time2 object.
     * Construct a new time instance with the specified hour and minute.
     * hour should be between 0-23, otherwise it should be set to 0. minute should be between 0-59,
     * otherwise they should be set to 0.
     * 
     * @param h  hour
     * @param m  minute
     */
    public Time2(int h, int m)
    { 
        if(h < MIN || h > (MAX_HOUR - 1)){
            h = MIN;  
        }
        
        if((m < MIN || m > (MAX_MINUTE - 1))){
            m = MIN;
        } 
        
        this._minFromMid = h * MAX_MINUTE + m;
    }

    // copy constructor
    /**
     * Copy constructor for Time2. Constructs a time with the same variables as another time.
     *
     * @param  other  The time object from which to construct the new time
     */
    public Time2(Time2 other)
    { 
        _minFromMid = other._minFromMid;
    }
    
    // get methods
    /**
     * Returns the hour of the time.
     *
     * @return  The hour of the time
     */
    public int getHour()
    { 
        return (_minFromMid / MAX_MINUTE);
    }
    
    /**
     * Returns the minute of the time.
     *
     * @return  The minute of the time
     */
    public int getMinute()
    { 
        return (_minFromMid % MAX_MINUTE);
    }
    
    // set methods
    /**
     * Changes the hour of the time. If an illegal number is received hour will remain unchanged.
     *
     * @return  The new hour
     */
    public void setHour(int num)
    { 
         if (num >= MIN && num < MAX_HOUR)
            _minFromMid = (_minFromMid % MAX_MINUTE + (num * MAX_MINUTE));
    }
    
    /**
     * Changes the minute of the time. If an illegal number is received minute will remain unchanged.
     *
     * @return  The new minute
     */
    public void setMinute(int num)
    { 
        if (num >= MIN && num <= MAX_MINUTE -1)
            _minFromMid = getHour() * MAX_MINUTE + num;
    }
    
    // time in minutes since midnight calculation method
    /**
     * Return the amount of minutes since midnight.
     *
     * @return  amount of minutes since midnight.
     */
    public int minFromMidnight()
    { 
        return _minFromMid;
    }
    
    // other methods
    /**
     * Check if the received time is equal to this time.
     *
     * @param other  The time to be compared with this time
     * 
     * @return True if the received time is equal to this time
     */
    public boolean equals(Time2 other)
    { 
        return (this._minFromMid == other._minFromMid);
    }
    
    /**
     * Check if this time is before a received time.
     *
     * @param other  The time to check if this time is before
     * 
     * @return  True if this time is before other time
     */
    public boolean before(Time2 other)
    { 
        return (this._minFromMid < other._minFromMid);
    }
    
    /**
     * Check if this time is after a received time.
     *
     * @param other  The time to check if this time is after
     * 
     * @return  True if this time is after other time
     */
    public boolean after(Time2 other)
    { 
        return (this._minFromMid > other._minFromMid);
    }
    
    /**
     * Calculates the difference (in minutes) between two times.
     *
     * @param other  The time to check the difference with. Assumption: this time is after other time.
     * 
     * @return  int difference in minutes
     */
    public int difference(Time2 other)
    { // as mentioned in the API - "parameter other - this time is after other time"
        return -((other.minFromMidnight() - this.minFromMidnight())); 
    }
    
    // toString method
    /**
     * Return a string representation of this time(hh:mm).
     *
     * @return  String representation of this time(hh:mm).
     */
    public String toString()
    { 
        if(this.getHour() > 9 && this.getMinute() > 9) {
            return this.getHour()+ ":" +this.getMinute();
        }
        else if (this.getHour() > 9 && this.getMinute() < 10) {
            return this.getHour()+ ":0" +this.getMinute();
        }
        else if (this.getHour() < 10 && this.getMinute() > 9) {
            return "0" +this.getHour()+ ":" +this.getMinute();
        }
        else {
            return "0" +this.getHour()+ ":0" +this.getMinute();
        }
    }
    
    // addition minutes calculation method
    /**
     * Copy current object and add requested minutes to new object.
     *
     * @param num  The minutes need to add.
     * 
     * @return  new update Time2 object.
     */
    public Time2 addMinutes(int num)
    {
        int m = MIN, h = MIN;
        if(num >= MIN){
            m = (this.minFromMidnight() + num) % MAX_MINUTE;
            h = ((((this.minFromMidnight() + num) - m) / MAX_MINUTE) % MAX_HOUR);
        }
        
        if(num < MIN){
            h = ((this.minFromMidnight() + num) / MAX_MINUTE);  
            m = (((this.minFromMidnight() + num) % MAX_MINUTE));  
            if(Math.abs(num) > this.minFromMidnight())
                h = MAX_HOUR + h;
            else 
                h = MAX_HOUR + h - 1;
        }
        
        Time2 updatedTime = new Time2(h, m);
        return updatedTime;  

    }
    
}// end of class Time2




